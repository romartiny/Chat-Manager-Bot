'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class Answer {
    constructor({ text, forwards, payload, attachments, duration }) {
        this.text = text;
        this.forwards = forwards;
        this.payload = payload;
        this.attachments = attachments;
        this.duration = duration;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}

// За правильность иерархии не ручаюсь :)
class QuestionManager {
    constructor() {
        this.questions = new Map();
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Middleware-функция - является основным функционалом.
     */
    get middleware() {
        return async (context, next) => {
            if (!context.is('message')) {
                await next();
                return;
            }
            const currentQuestion = this.questions.get(context.senderId);
            if (currentQuestion) {
                currentQuestion.resolve(new Answer({
                    text: context.text,
                    forwards: context.forwards,
                    payload: context.messagePayload,
                    attachments: context.attachments,
                    duration: Date.now() - currentQuestion.startTime
                }));
                return this.questions.delete(context.senderId);
            }
            /**
             * @param message  Отправляемое сообщение (вопрос)
             * @param params Параметры сообщения
             */
            context.question = async (message, params) => {
                if (!message) {
                    throw new TypeError('Parameter `message` is required');
                }
                await context.send(message, params);
                return new Promise((resolve) => {
                    const userId = params && params.targetUserId
                        ? params.targetUserId
                        : context.senderId;
                    this.questions.set(userId, {
                        resolve,
                        startTime: Date.now()
                    });
                });
            };
            await next();
        };
    }
}

exports.Answer = Answer;
exports.QuestionManager = QuestionManager;
exports.default = QuestionManager;
